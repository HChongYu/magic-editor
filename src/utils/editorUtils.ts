import { Editor } from '@tiptap/vue-3'
import StarterKit from '@tiptap/starter-kit'
import { Extension } from '@tiptap/core'
import { JSONContent } from '@tiptap/core'
import { EmojiNode } from '@/extensions/EmojiNode'
import { DoubleTextNode } from '@/extensions/DoubleTextNode'
import TextBlockNode from '@/extensions/TextBlockNode'
import { TravelCardNode } from '@/extensions/TravelCardNode'

// ÁºñËæëÂô®Â∑•ÂÖ∑Á±ª
export class EditorUtils {
    private editor: Editor | null = null

    constructor(editor?: Editor) {
        this.editor = editor || null
    }

    // ËÆæÁΩÆÁºñËæëÂô®ÂÆû‰æã
    setEditor(editor: Editor) {
        this.editor = editor
    }

    // Ê£ÄÊü•ÁºñËæëÂô®ÊòØÂê¶ÂèØÁî®
    private checkEditor(): boolean {
        if (!this.editor) {
            console.warn('ÁºñËæëÂô®ÂÆû‰æãÊú™ËÆæÁΩÆ')
            return false
        }
        return true
    }

    // ========== ËäÇÁÇπÊèíÂÖ•ÊñπÊ≥ï ==========

    // ÊèíÂÖ•ÊóÖÊ∏∏Âç°ÁâáËäÇÁÇπ
    insertTravelCard(attrs?: {
        title?: string
        description?: string
        imageUrl?: string
        location?: string
        price?: string
    }) {
        if (!this.checkEditor()) return false

        const defaultAttrs = {
            title: 'ÊóÖÊ∏∏ÁõÆÁöÑÂú∞',
            description: 'ËøôÈáåÊòØÊèèËø∞‰ø°ÊÅØ',
            imageUrl: 'https://via.placeholder.com/300x200',
            location: '‰ΩçÁΩÆ‰ø°ÊÅØ',
            price: '¬•999'
        }

        return this.editor!.chain()
            .focus()
            .insertTravelCard({ ...defaultAttrs, ...attrs })
            .run()
    }

    // ÊèíÂÖ•ÂèåÊñáÊú¨ËäÇÁÇπ
    insertDoubleText(attrs?: {
        topText?: string
        bottomText?: string
        topColor?: string
        bottomColor?: string
        topFontSize?: string
        bottomFontSize?: string
    }) {
        if (!this.checkEditor()) return false

        const defaultAttrs = {
            topText: '‰∏äÊÆµÊñáÂ≠ó',
            bottomText: '‰∏ãÊÆµÊñáÂ≠ó',
            topColor: '#333333',
            bottomColor: '#666666',
            topFontSize: '16px',
            bottomFontSize: '14px'
        }

        return this.editor!.chain()
            .focus()
            .insertContent({
                type: 'doubleTextNode',
                attrs: { ...defaultAttrs, ...attrs }
            })
            .run()
    }

    // ÊèíÂÖ•Ë°®ÊÉÖÁ¨¶Âè∑ËäÇÁÇπ
    insertEmoji(attrs?: {
        emoji?: string
        label?: string
    }) {
        if (!this.checkEditor()) return false

        const defaultAttrs = {
            emoji: 'üòä',
            label: 'ÁÇπÂáªÁºñËæëÊ†áÁ≠æ'
        }

        return this.editor!.chain()
            .focus()
            .insertEmoji({ type: 'emoji', ...defaultAttrs, ...attrs })
            .run()
    }

    // ÊèíÂÖ•ÊñáÊú¨ÂùóËäÇÁÇπ
    insertTextBlock(attrs?: {
        content?: string
        backgroundColor?: string
        textColor?: string
    }) {
        if (!this.checkEditor()) return false

        const defaultAttrs = {
            content: 'ËøôÊòØ‰∏Ä‰∏™ÊñáÊú¨Âùó',
            backgroundColor: '#f5f5f5',
            textColor: '#333333'
        }

        return this.editor!.chain()
            .focus()
            .insertContent({
                type: 'textBlockNode',
                attrs: { ...defaultAttrs, ...attrs }
            })
            .run()
    }

    // ========== ÂÜÖÂÆπÊìç‰ΩúÊñπÊ≥ï ==========

    // Ëé∑ÂèñÁºñËæëÂô®ÂÜÖÂÆπ
    getContent(format: 'html' | 'json' | 'text' = 'html') {
        if (!this.checkEditor()) return ''

        switch (format) {
            case 'html':
                return this.editor!.getHTML()
            case 'json':
                return this.editor!.getJSON()
            case 'text':
                return this.editor!.getText()
            default:
                return this.editor!.getHTML()
        }
    }

    // ËÆæÁΩÆÁºñËæëÂô®ÂÜÖÂÆπ
    setContent(content: string | JSONContent) {
        if (!this.checkEditor()) return false

        return this.editor!.commands.setContent(content)
    }

    // Ê∏ÖÁ©∫ÁºñËæëÂô®
    clearContent() {
        if (!this.checkEditor()) return false

        return this.editor!.commands.clearContent()
    }

    // ========== ÊñáÊú¨Ê†ºÂºèÂåñÊñπÊ≥ï ==========

    // Âä†Á≤ó
    toggleBold() {
        if (!this.checkEditor()) return false
        return this.editor!.chain().focus().toggleBold().run()
    }

    // Êñú‰Ωì
    toggleItalic() {
        if (!this.checkEditor()) return false
        return this.editor!.chain().focus().toggleItalic().run()
    }

    // ‰∏ãÂàíÁ∫ø
    toggleUnderline() {
        if (!this.checkEditor()) return false
        return this.editor!.chain().focus().toggleUnderline().run()
    }

    // Âà†Èô§Á∫ø
    toggleStrike() {
        if (!this.checkEditor()) return false
        return this.editor!.chain().focus().toggleStrike().run()
    }

    // ËÆæÁΩÆÊ†áÈ¢òÁ∫ßÂà´
    setHeading(level: 1 | 2 | 3 | 4 | 5 | 6) {
        if (!this.checkEditor()) return false
        return this.editor!.chain().focus().toggleHeading({ level }).run()
    }

    // ËÆæÁΩÆÊÆµËêΩ
    setParagraph() {
        if (!this.checkEditor()) return false
        return this.editor!.chain().focus().setParagraph().run()
    }

    // È°πÁõÆÁ¨¶Âè∑ÂàóË°®
    toggleBulletList() {
        if (!this.checkEditor()) return false
        return this.editor!.chain().focus().toggleBulletList().run()
    }

    // ÊúâÂ∫èÂàóË°®
    toggleOrderedList() {
        if (!this.checkEditor()) return false
        return this.editor!.chain().focus().toggleOrderedList().run()
    }

    // ÂºïÁî®Âùó
    toggleBlockquote() {
        if (!this.checkEditor()) return false
        return this.editor!.chain().focus().toggleBlockquote().run()
    }

    // ========== ÈÄâÊã©‰∏éÂÖâÊ†áÊìç‰Ωú ==========

    // ËÅöÁÑ¶ÁºñËæëÂô®
    focus() {
        if (!this.checkEditor()) return false
        return this.editor!.commands.focus()
    }

    // Ëé∑ÂèñÂΩìÂâçÈÄâÊã©ËåÉÂõ¥
    getSelection() {
        if (!this.checkEditor()) return null
        return this.editor!.state.selection
    }

    // ËÆæÁΩÆÈÄâÊã©ËåÉÂõ¥
    setSelection(from: number, to?: number) {
        if (!this.checkEditor()) return false
        return this.editor!.commands.setTextSelection({ from, to: to || from })
    }

    // ÈÄâÊã©ÂÖ®ÈÉ®ÂÜÖÂÆπ
    selectAll() {
        if (!this.checkEditor()) return false
        return this.editor!.commands.selectAll()
    }

    // ========== ËäÇÁÇπÊìç‰ΩúÊñπÊ≥ï ==========

    // Ëé∑ÂèñÈÄâ‰∏≠ÁöÑËäÇÁÇπ‰ø°ÊÅØ
    getSelectedNodeInfo() {
        if (!this.checkEditor()) return null

        const { selection } = this.editor!.state
        const { $from } = selection

        for (let i = $from.depth; i > 0; i--) {
            const node = $from.node(i)
            if (['doubleTextNode', 'emojiNode', 'travelCardNode', 'textBlockNode'].includes(node.type.name)) {
                return {
                    type: node.type.name,
                    attrs: node.attrs,
                    content: node.content
                }
            }
        }

        return null
    }

    // Â§çÂà∂ÈÄâ‰∏≠ÁöÑËäÇÁÇπ
    copySelectedNode() {
        if (!this.checkEditor()) return false

        const { state } = this.editor!
        const { selection, doc } = state
        let nodeInfo: any = null

        // Êü•ÊâæÈÄâ‰∏≠ÁöÑËá™ÂÆö‰πâËäÇÁÇπ
        doc.nodesBetween(selection.from, selection.to, (node: any, pos: number) => {
            if (['doubleTextNode', 'emojiNode', 'travelCardNode', 'textBlockNode'].includes(node.type.name)) {
                nodeInfo = { node, pos }
                return false
            }
        })

        if (!nodeInfo) {
            const resolvedPos = doc.resolve(selection.from)
            for (let depth = resolvedPos.depth; depth > 0; depth--) {
                const nodeAtDepth = resolvedPos.node(depth)
                if (['doubleTextNode', 'emojiNode', 'travelCardNode', 'textBlockNode'].includes(nodeAtDepth.type.name)) {
                    nodeInfo = { node: nodeAtDepth, pos: resolvedPos.start(depth) - 1 }
                    break
                }
            }
        }

        if (nodeInfo) {
            const { tr } = state
            const insertPos = selection.to
            tr.insert(insertPos, nodeInfo.node.copy())
            this.editor!.view.dispatch(tr)
            return true
        }

        return false
    }

    // Âà†Èô§ÈÄâ‰∏≠ÁöÑËäÇÁÇπ
    deleteSelectedNode() {
        if (!this.checkEditor()) return false

        const { state } = this.editor!
        const { selection, doc } = state
        let nodeInfo: any = null

        // Êü•ÊâæÈÄâ‰∏≠ÁöÑËá™ÂÆö‰πâËäÇÁÇπ
        doc.nodesBetween(selection.from, selection.to, (node: any, pos: number) => {
            if (['doubleTextNode', 'emojiNode', 'travelCardNode', 'textBlockNode'].includes(node.type.name)) {
                nodeInfo = { node, pos, size: node.nodeSize }
                return false
            }
        })

        if (!nodeInfo) {
            const resolvedPos = doc.resolve(selection.from)
            for (let depth = resolvedPos.depth; depth > 0; depth--) {
                const nodeAtDepth = resolvedPos.node(depth)
                if (['doubleTextNode', 'emojiNode', 'travelCardNode', 'textBlockNode'].includes(nodeAtDepth.type.name)) {
                    const posAtDepth = resolvedPos.start(depth) - 1
                    nodeInfo = { node: nodeAtDepth, pos: posAtDepth, size: nodeAtDepth.nodeSize }
                    break
                }
            }
        }

        if (nodeInfo) {
            const { tr } = state
            tr.delete(nodeInfo.pos, nodeInfo.pos + nodeInfo.size)
            this.editor!.view.dispatch(tr)
            return true
        }

        return false
    }

    // ========== Êâ©Â±ïÁÆ°ÁêÜÊñπÊ≥ï ==========

    // Ëé∑ÂèñÈªòËÆ§Êâ©Â±ïÈÖçÁΩÆ
    static getDefaultExtensions() {
        return [
            StarterKit.configure({
                bulletList: false,
                heading: false,
                paragraph: false,
                blockquote: false,
            }),
            EmojiNode,
            DoubleTextNode,
            TextBlockNode,
            TravelCardNode,
        ]
    }

    // ÂàõÂª∫ÁºñËæëÂô®ÂÆû‰æã
    static createEditor(options: {
        content?: string | JSONContent
        extensions?: Extension[]
        onUpdate?: (editor: Editor) => void
        onSelectionUpdate?: (editor: Editor) => void
        onFocus?: (editor: Editor) => void
        onBlur?: (editor: Editor) => void
    } = {}) {
        const {
            content = '',
            extensions = EditorUtils.getDefaultExtensions(),
            onUpdate,
            onSelectionUpdate,
            onFocus,
            onBlur
        } = options

        return new Editor({
            content,
            extensions,
            onUpdate: (editor) => {
                // Ëá™Âä®‰øùÂ≠òÈÄªËæë
            },
            onSelectionUpdate: (editor) => {


            },
            onFocus: (editor) => {

                // ÊòæÁ§∫ÁºñËæëÊèêÁ§∫
            },
            onBlur: (editor) => {
                console.log('ÁºñËæëÂô®Â§±ÂéªÁÑ¶ÁÇπ')
                // ‰øùÂ≠òËçâ
            }
        })
    }

    // ========== ÂÆûÁî®Â∑•ÂÖ∑ÊñπÊ≥ï ==========

    // Ëé∑ÂèñÁºñËæëÂô®ÁªüËÆ°‰ø°ÊÅØ
    getStats() {
        if (!this.checkEditor()) return null

        const content = this.editor!.getText()
        const words = content.trim().split(/\s+/).filter(word => word.length > 0)

        return {
            characters: content.length,
            charactersWithoutSpaces: content.replace(/\s/g, '').length,
            words: words.length,
            paragraphs: content.split('\n\n').filter(p => p.trim().length > 0).length
        }
    }

    // Êí§ÈîÄ
    undo() {
        if (!this.checkEditor()) return false
        return this.editor!.commands.undo()
    }

    // ÈáçÂÅö
    redo() {
        if (!this.checkEditor()) return false
        return this.editor!.commands.redo()
    }

    // Ê£ÄÊü•ÊòØÂê¶ÂèØ‰ª•Êí§ÈîÄ
    canUndo() {
        if (!this.checkEditor()) return false
        return this.editor!.can().undo()
    }

    // Ê£ÄÊü•ÊòØÂê¶ÂèØ‰ª•ÈáçÂÅö
    canRedo() {
        if (!this.checkEditor()) return false
        return this.editor!.can().redo()
    }

    // ÈîÄÊØÅÁºñËæëÂô®
    destroy() {
        if (this.editor) {
            this.editor.destroy()
            this.editor = null
        }
    }
}

// Âçï‰æãÊ®°ÂºèÁöÑÁºñËæëÂô®Â∑•ÂÖ∑ÂÆû‰æã
let globalEditorUtils: EditorUtils | null = null

// Ëé∑ÂèñÂÖ®Â±ÄÁºñËæëÂô®Â∑•ÂÖ∑ÂÆû‰æã
export const getEditorUtils = (editor?: Editor): EditorUtils => {
    if (!globalEditorUtils) {
        globalEditorUtils = new EditorUtils(editor)
    } else if (editor) {
        globalEditorUtils.setEditor(editor)
    }
    return globalEditorUtils
}

// Â∑•ÂÖ∑Ê†èÂä®‰ΩúÂàõÂª∫ÂáΩÊï∞
export const createToolbarActions = (editorUtils: EditorUtils) => {
    return {
        // Ê†ºÂºèÂåñÂä®‰Ωú
        formatting: {
            bold: () => editorUtils.toggleBold(),
            italic: () => editorUtils.toggleItalic(),
            underline: () => editorUtils.toggleUnderline(),
            strike: () => editorUtils.toggleStrike(),
            h1: () => editorUtils.setHeading(1),
            h2: () => editorUtils.setHeading(2),
            h3: () => editorUtils.setHeading(3),
            paragraph: () => editorUtils.setParagraph(),
            bulletList: () => editorUtils.toggleBulletList(),
            orderedList: () => editorUtils.toggleOrderedList(),
            blockquote: () => editorUtils.toggleBlockquote(),
        },

        // ËäÇÁÇπÊèíÂÖ•Âä®‰Ωú
        insert: {
            travelCard: (attrs?: any) => editorUtils.insertTravelCard(attrs),
            doubleText: (attrs?: any) => editorUtils.insertDoubleText(attrs),
            emoji: (attrs?: any) => editorUtils.insertEmoji(attrs),
            textBlock: (attrs?: any) => editorUtils.insertTextBlock(attrs),
        },

        // ËäÇÁÇπÊìç‰ΩúÂä®‰Ωú
        node: {
            copy: () => editorUtils.copySelectedNode(),
            delete: () => editorUtils.deleteSelectedNode(),
            getInfo: () => editorUtils.getSelectedNodeInfo(),
        },

        // ÁºñËæëÂô®Êìç‰ΩúÂä®‰Ωú
        editor: {
            undo: () => editorUtils.undo(),
            redo: () => editorUtils.redo(),
            selectAll: () => editorUtils.selectAll(),
            focus: () => editorUtils.focus(),
            clear: () => editorUtils.clearContent(),
            getStats: () => editorUtils.getStats(),
        }
    }
}

// ÈªòËÆ§ÂØºÂá∫
export default EditorUtils